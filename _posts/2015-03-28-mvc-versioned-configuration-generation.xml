---
layout: post
title: "MVC Versioned Configuration Generation"
description: "Amazingly simple way to model configurations. By making it MVC configurations."
category: "Software Design"
tags: ["Sofware Design", "Configurations"]
---
{% include JB/setup %}

The scenarios is as so, we have a configuration file that is consume by many parts in the system. 
This config data is kept in some storage, say a database. You have a service that builds these configuration files but
we know that this configuration will need to be updated in the future. 

How do we design this configuration generation system such that it will scale easily to rapidly changing configs, while
making backwards compatibility easy? This requires a 2 part process.


[1] Define configurations as a Model View Controller (MVC). If configuration data is kept seperate from the view or the
resultant configuration file, we can prevent making breaking changes to the configuration data. New requirements should
not need constant changes to the datastore.

The configuration service will then controll the configuration data, and generates the specific versions of the 
configuration file.


[2] We use some neat coding trick for the configuration file generation that only applys diffs to the last version.
So if we define a config and controller that manages two versions. Essentially version two of the configuration 
controller will first generate version one, then apply any diffs it needs on top of version one!. 

{% highlight python linenos=table %}
import json

# assume we got this from a DB connection
config_data = {
    'controller' : {
        'bots': [
            {
                'name': 'reddit_bot',
                'action': 'browse_reddit',
                'comments': 'prefers r/aww',
                'is_active': False
            },
        ]
    }
}


class ConfigController(object):
    def __init__(self, config_data):
        self.config_data = config_data
    
    def dump(self, config):
        print(json.dumps(config))


class Version1Config(ConfigController): 
    '''
    Version 1 dumps eveything as is into JSON
    '''
    def __init__(self, config_data):
        ConfigController.__init__(self, config_data) 

    def create(self):
        config = self.config_data
        config['version'] = 1
        return config
        

class Version2Config(Version1Config):
    '''
    Version 2 adds comments and changes a field name 
    '''
    def __init__(self, config):
        Version1Config.__init__(self, config_data) 
    
    def create(self):
        old_config = Version1Config.create()
        
        config['version'] = 2
        config['comments'] = 'ops team didn\'t know what this config does, adding message.'
        config['bot_controllers'] = old_config['controllers'] 
        return config

v2 = Version2Config(config_data)
v2.dump(v2.create())
{% endhighlight %}

With the above example, we maintain the config data in memory between version, and only convert it to the right 
representation at the end.

It allows rolling changes to configurations that build on top of previous versions, this minimizes the amount of
places we need to do changes, and prevents regression issues when the system transitions between configuration versions.
