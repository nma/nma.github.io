{"componentChunkName":"component---src-templates-blog-post-js","path":"/2014-12-26-recursion-in-stacks/","result":{"data":{"site":{"siteMetadata":{"title":"Blog","author":"Nick Ma"}},"markdownRemark":{"id":"7015c6c2-03b9-5ffb-9b51-1e5a0447eb4b","excerpt":"Recursion is one of the most common topics in interviews. Recursive solutions usually consist of less code than an interative solution (but not always).\nOne…","html":"<p>Recursion is one of the most common topics in interviews. Recursive solutions usually consist of less code than an interative solution (but not always).\nOne epiphany I had recently while reviewing common recursive problems is that recursion can be thought of in terms of stacks.</p>\n<p>Lets say that you were asked to perform a postorder traversal on a binary tree. How would you write the code for this? The most common answer will involve recursion:\nStart traversing the tree from the top, first print the value of the current node, then traverse the left most node, then the right most node; if this node is a leaf, then exit the function.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/nickma.com/BinaryTree.png\" alt=\"BinaryTree\"></p>\n<p>{% highlight python linenos=table %}\ndef postorder(root):\nprint root.value</p>\n<p>if root.left is not None:\npostorder(root.left)</p>\n<p>if root.right is not None:\npostorder(root.right)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return</code></pre></div>\n<p>{% endhighlight %}</p>\n<p>Now if we need to solve the same question, but without using recursion, how would you do it? (this question was actually asking how well can you visualize recursion).\nIn a nutshell, when the program starts executing, a certain contiguous section of memory is set aside for the program called the stack. <a href=\"http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/stack.html\">Source</a>\nTo better visualize what recursion is, we need to take a look at the program stack for the above method.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/nickma.com/ExecutionStack.png\" alt=\"ProgramStack\"></p>\n<p>Everytime a new function is called, it gets added onto this stack, once this method hits a return statement, it gets popped off the stack, and we start executing the last method on the stack.\nA recursive function may be called many times (depending on the height of the tree and etc), this is why you see stack overflow errors since the recursive call doesn’t terminate and use up all the stack memory!</p>\n<p>If you take a look at the program call stack, the recursive execution is basically using the execution stack to implicitly keep track of the traversal order.\nWe can now write a method to iteratively keep track of the traversal order with an explicit stack.</p>\n<p>{% highlight python linenos=table %}\ndef postorder(root): # using a list as a stack\nstack = []</p>\n<p>if root is not None:\nstack.append(root)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">while len(stack) != 0:\n    node = stack.pop()\n    print node.value\n\n    if node.right != None:\n        stack.append(node.right)\n\n    if node.left != None:\n        stack.append(node.left)\n\nreturn</code></pre></div>\n<p>{% endhighlight %}</p>\n<p>We create a stack using a python list, and add our root node as the first Node. Then we push onto the stack starting with the right node first. Since our stack is LIFO, we have to make sure our left node is the first on that gets popped off.</p>\n<p>{% highlight python %}\nclass Node:\ndef <strong>init</strong>(self, value, left=None, right=None):\nself.value = value\nself.right = right\nself.left = left</p>\n<p>root = Node(50)\nroot.right = Node(51)\nroot.left = Node(18, Node(9), Node(24))\n{% endhighlight %}</p>\n<p>Here is the quick working code <a href=\"http://www.pythontutor.com/visualize.html#code=class+Node%3A%0A++++def+__init__(self,+value,+left%3DNone,+right%3DNone)%3A%0A++++++++self.value+%3D+value%0A++++++++self.right+%3D+right%0A++++++++self.left+%3D+left%0A%0Aroot+%3D+Node(50)%0Aroot.right+%3D+Node(51)%0Aroot.left+%3D+Node(18,+Node(9),+Node(24))%0A%0Adef+postorder(root)%3A%0A++++%23+using+a+list+as+a+stack%0A++++stack+%3D+%5B%5D%0A++++%0A++++if+root+is+not+None%3A%0A++++++++stack.append(root)%0A%0A++++while+len(stack)+!%3D+0%3A%0A++++++++node+%3D+stack.pop()%0A++++++++print+node.value%0A++++++++%0A++++++++if+node.right+!%3D+None%3A%0A++++++++++++stack.append(node.right)%0A++++++++%0A++++++++if+node.left+!%3D+None%3A%0A++++++++++++stack.append(node.left)%0A%0A%0A++++return%0A%0Apostorder(root)&#x26;mode=display&#x26;origin=opt-frontend.js&#x26;cumulative=false&#x26;heapPrimitives=false&#x26;drawParentPointers=false&#x26;textReferences=false&#x26;showOnlyOutputs=false&#x26;py=2&#x26;rawInputLstJSON=%5B%5D&#x26;curInstr=31\">visualization</a>\nfor this problem, start at around step 32 to avoid the tree declaration.</p>","frontmatter":{"title":"Thinking about Recursion in Stacks","date":"December 26, 2014"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2014-12-26-recursion-in-stacks/","previous":null,"next":{"fields":{"slug":"/2016-07-07-vim-save-as-sudo/"},"frontmatter":{"title":"Vim Save as Sudo"}}}}}